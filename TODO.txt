TODO:

- Syntax for closures
- Think about how closures and universes interact
- Figure out how typeclass instances work with import resolution
- Update parser to EBNF syntax

LONG-TERM TODO:

- Error on user-defined identifiers that start with @
- Linearity: count appearances of bindings in expressions
- Warn when not using the result value of a progn (any expression with type other than unit)
- abort builtin
- do special operator
- doparallel special operator
- Define function pointer type
- Define `function` operator
- Define an integer-cast thing to cast integers or some such
- Validate foreign function return types
- Bitwise operators
- Runtime support for saturation arithmetic
- CUDA backend
- C+OpenMP backend
- Define syntax for linear iteration operators
- Track source positions

DONE:

- Utils
- Set
- Map
- Ident structure
- Basic Module structure
- CST
- Parser tests
- Parser
- Symbol resolution in modules
- Parse files
- Parse floating point numbers
- Test float parsing
- Process escape sequences in parsed strings
- Define the expression AST datatype
- Parse RCST nodes into AST nodes
- Alpha renaming
- Define the toplevel AST datatype
- Handle type declarations
- Handle datatype declarations
- C++ backend
- Type checking
- Compile type aliases
- Compile disjunctions
- Parse defmodule declarations into a proper module instance
- Compile function calls
- Modular arithmetic
- Checked arithmetic
- Saturation arithmetic
- Fix function declaration types
- true, false and nil
- Boolean function not
- Compile prelude.hpp into an SML file with the prelude embedded into a string
- CLI interface
- Start REPL from CLI
- Compile files from CLI
- Builtin integer/float comparison functions
- Alpha top_ast
- OAST top_ast
- RCST->OAST top_ast
- OAST top_ast -> Alpha top_ast
- Turn params from symbols to variables
- Update AST.transformTop to use Alpha.top_ast instead of RCST
- Fix parameter lookup
- Parse definstance declarations
- Compile typeclass instances to a list of HIR generic functions
- handle defclass declarations
- resolve should have an extra argument with the type parameter environment
  (e.g., in a generic function definition, the set of defined type parameters)
- handle definstance declarations
- Define austral.ext.cffi module
- Define static array type
- Parse static-array type specifier
- Implement static-array-length
- Compile string literals as static array constructors
- Implement foreign-funcall
- OrderedSet.toUnordered
- declaration AST between AST and TAST
- better handling of type parameters throughout the codebase
- Generic functions
- Implement austral.ext.cffi:size-of
- Handle foreign functions that return void in foreign-funcall
- Add austral.ext.cffi:foreign-pointer type
- Fix function calls being thrown out in the all-but-last body of progn (MIR, HIR)
- Fix escaped strings
- Fix that bug where function calls in progns arent made for some reason
- Replace progns with seqs
- Use `the` only to verify types match
- Compile the prelude
- Implement austral.ext.cffi:malloc (generic function, prelude)
- Implement austral.ext.cffi:free (generic function, prelude)
- Find the set of type variables in a type
- Predicate to determine if a function is return-type polymorphic
- Call non-RTP generic functions
- Call RTP generic functions in a `the` context
- Implement proper type/arguments matching/unification
- Add support for an --entrypoint flag to define the main() function
- Austral prelude
- Implement austral.ext.cffi:null-pointer (built-in)
- eq builtin for pointers
- Implement austral.ext.cffi:null? (generic function, prelude)
- `construct` builtin
- Parse bind expressions
- Tuple bind
- Parse case expressions
- Case expressions
- address-of
- Static arrays should contain the length in their runtime representation, not at the type-level
- Monomorphize types
- Monomorphize TAST
- Foreign funcall: valid types
- Foreign funcall: extract array pointer
- Parse defcfun forms
- Foreign function in the fenv
- address-of should only work on mutable variables
- Error when defining multiple foreign functions with the same raw name
- Implement defcfun
- Augment calls to foreign functions
- Remove foreign-funcall
- Implement austral.ext.cffi:cast
- Fix prelude
- Generalize that foldl2-like pattern
- Implement ordered maps
- Diff contexts for monomorphizations
- Add ID to function monomorphs
- Hoist new monomorphs
- Function definition environment
- Store generic function definitions
- Expand monomorphs
- New HIR
- New MTAST->HIR
- New MIR
- New HIR->MIR
- New LIR
- LIR pass
- C backend
- C runtime file and script
- Update compiler to use C backend
- C AST renderer
- Expand tuple types
- Refactor: ForeignPointer to Address
- Refactor: load works on addresses only, returns dereferenced value
- Refactor: store works on addresses only, returns stored value
- GenericFuncall: replace list of type args with map of type param names to type args
- Fix bug with type matching in generic function calls
- Refactor: PositiveAddress type
- Refactor: load/store only work on PositiveAddress types
- Compile defdisjunctions
- Fully flatten the intermediate representation early on
- `the` for float constants
- Show symbol names in error messages
- usize alias
- isize alias
- Rename disjunctions to datatypes
- Refactor: malloc builtin
- Refactor: free builtin
- Null pointer builtin
- Builtin to turn an address to a positive address
- malloc/load/store/free test
- address-offset builtin
- test address-offset
- Lift static arrays to (length, ptr) tuples in the LIR pass
- String literals
- Compile defcfun all the way down to extern
- Separate type decl environment from datatype def environment
- Fix typechecking of generic disjunctiom instances
- Fix disjunction data access
- Record types
- defrecord toplevel form
- record constructor form
- slot getter
- while special operator
- parse while special forms
- Linearity: define linear and unrestricted kinds
- Linearity: store kind information in disjunction/record types
- Linearity: all type variables are linear
- Linearity: Syntax for specifying kinds in disjunctions and records
- Syntax: expressions
- Update parser tests
- `import ... as` syntax
- Parser: type specifiers
- Syntax: declarations
- Constrain identifier alphabet further
- Parser: visibility declaration
- Separate IRs from passes
- and, or operators
- Syntax: docstrings
- Lexer, or fix parser infinite recursion
- Parse logical expressions
- Parse tuple expressions
- Parse comparison expressions
- Parse block expressions
- Parse function calls
- Parse tuple projections
- Parse let expressions
- Expression parsing tests
- Parser: docstrings
- Parse arithmetic expressions
- Parser: module definitions
- Different alphabets for different types of identifiers
- Parser: record definitions
- Parser: variant definitions
- Parser: function definitions
- Parser and syntax: type visibility
- Module objects
- Type module
- Move errors to their own module
- Better error messages
- Import validation: imports refer to modules that exist in the menv
- Import validation: imports refer to declarations that exist in the referenced module
- Import validation: imports refer to declarations that are public or opaque
- Module environment
- Import validation: imports don't collide with each other
- Fix imports to properly support renames
- Ordered decl IR
- Resolved decl IR
- Type-augmented declarations
- Syntax->OrderedDecl pass
- OrderedDecl->ResolvedDecl pass
- ResolvedDecl->TypedDecl pass
- Transform type specifiers to type objects
- Import validation: ensure local declarations don't collide with import names
- TypedDecl->Module pass
- Simplify TypedDecl->Module pass
- Finalize syntax for typeclasses
- Review generic function syntax
- Review import syntax
- Update Syntax types to EBNF syntax
