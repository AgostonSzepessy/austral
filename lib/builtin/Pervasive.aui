module Austral.Pervasive is
    union Option[T: Type]: Type is
        case None;
        case Some is
            value: T;
    end;

    union Either[L: Type, R: Type]: Type is
        case Left is
            left: L;
        case Right is
            right: R;
    end;

    generic [T: Free, R: Region]
    function Deref(ref: &[T, R]): T;

    generic [T: Free, R: Region]
    function Deref_Write(ref: &![T, R]): T;

    generic [T: Type]
    function Fixed_Array_Size(arr: FixedArray[T]): Index;

    function Abort(message: FixedArray[Nat8]): Unit;

    type RootCapability : Linear;

    constant Maximum_Nat8: Nat8;
    constant Maximum_Nat16: Nat16;
    constant Maximum_Nat32: Nat32;
    constant Maximum_Nat64: Nat64;

    constant Minimum_Int8: Int8;
    constant Maximum_Int8: Int8;

    constant Minimum_Int16: Int16;
    constant Maximum_Int16: Int16;

    constant Minimum_Int32: Int32;
    constant Maximum_Int32: Int32;

    constant Minimum_Int64: Int64;
    constant Maximum_Int64: Int64;

    constant Minimum_Index: Index;
    constant Maximum_Index: Index;

    typeclass Trapping_Arithmetic(T: Type) is
        method Trapping_Add(lhs: T, rhs: T): T;
        method Trapping_Subtract(lhs: T, rhs: T): T;
        method Trapping_Multiply(lhs: T, rhs: T): T;
        method Trapping_Divide(lhs: T, rhs: T): T;
    end;

    typeclass Modular_Arithmetic(T: Type) is
        method Modular_Add(lhs: T, rhs: T): T;
        method Modular_Subtract(lhs: T, rhs: T): T;
        method Modular_Multiply(lhs: T, rhs: T): T;
        method Modular_Divide(lhs: T, rhs: T): T;
    end;

    instance Trapping_Arithmetic(Nat8);
    instance Trapping_Arithmetic(Int8);
    instance Trapping_Arithmetic(Nat16);
    instance Trapping_Arithmetic(Int16);
    instance Trapping_Arithmetic(Nat32);
    instance Trapping_Arithmetic(Int32);
    instance Trapping_Arithmetic(Nat64);
    instance Trapping_Arithmetic(Int64);
    instance Trapping_Arithmetic(Index);
    instance Trapping_Arithmetic(Float64);

    instance Modular_Arithmetic(Nat8);
    instance Modular_Arithmetic(Int8);
    instance Modular_Arithmetic(Nat16);
    instance Modular_Arithmetic(Int16);
    instance Modular_Arithmetic(Nat32);
    instance Modular_Arithmetic(Int32);
    instance Modular_Arithmetic(Nat64);
    instance Modular_Arithmetic(Int64);
    instance Modular_Arithmetic(Index);

    typeclass Printable(A: Free) is
        method Print(value: A): Unit;

        method Print_Fixed_Array(array: FixedArray[A]): Unit;
    end;

    instance Printable(Unit);
    instance Printable(Bool);
    instance Printable(Nat8);
    instance Printable(Int8);
    instance Printable(Nat16);
    instance Printable(Int16);
    instance Printable(Nat32);
    instance Printable(Int32);
    instance Printable(Nat64);
    instance Printable(Int64);
    instance Printable(Index);
    instance Printable(Float32);
    instance Printable(Float64);
    generic [B: Free(Printable)]
    instance Printable(FixedArray[B]);

    generic [T: Free(Printable)]
    function PrintLn(value: T): Unit;
end module.