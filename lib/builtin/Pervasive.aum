module body Austral.Pervasive is
    generic [T: Free, R: Region]
    function Deref(ref: &[T, R]): T is
        return @embed(T, "*$1", ref);
    end;

    generic [T: Free, R: Region]
    function Deref_Write(ref: &![T, R]): T is
        return @embed(T, "*$1", ref);
    end;

    generic [T: Type]
    function Fixed_Array_Size(arr: FixedArray[T]): Index is
        return @embed(Index, "$1.size", arr);
    end;

    function Abort(message: FixedArray[Nat8]): Unit is
        return @embed(Unit, "au_abort($1)", message);
    end;

    record RootCapability: Linear is
        value: Unit;
    end;

    function surrenderRoot(cap: RootCapability): Unit is
        let { value: Unit } := cap;
        return nil;
    end;

    constant Minimum_Nat8: Int8 := 0;
    constant Maximum_Nat8: Nat8 := @embed(Nat8, "UINT8_MAX");

    constant Minimum_Nat16: Int8 := 0;
    constant Maximum_Nat16: Nat16 := @embed(Nat16, "UINT16_MAX");

    constant Minimum_Nat32: Int8 := 0;
    constant Maximum_Nat32: Nat32 := @embed(Nat32, "UINT32_MAX");

    constant Minimum_Nat64: Int8 := 0;
    constant Maximum_Nat64: Nat64 := @embed(Nat64, "UINT64_MAX");

    constant Minimum_Int8: Int8 := @embed(Int8, "INT8_MIN");
    constant Maximum_Int8: Int8 := @embed(Int8, "INT8_MAX");

    constant Minimum_Int16: Int16 := @embed(Int16, "INT16_MIN");
    constant Maximum_Int16: Int16 := @embed(Int16, "INT16_MAX");

    constant Minimum_Int32: Int32 := @embed(Int32, "INT32_MIN");
    constant Maximum_Int32: Int32 := @embed(Int32, "INT32_MAX");

    constant Minimum_Int64: Int64 := @embed(Int64, "INT64_MIN");
    constant Maximum_Int64: Int64 := @embed(Int64, "INT64_MAX");

    constant Minimum_Index: Index := 0;
    constant Maximum_Index: Index := @embed(Index, "SIZE_MAX");

    ---
    --- Trapping Arithmetic
    ---

    instance TrappingArithmetic(Nat8) is
        method trappingAdd(lhs: Nat8, rhs: Nat8): Nat8 is
            let result: Nat8 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingAdd (Nat8)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: Nat8, rhs: Nat8): Nat8 is
            let result: Nat8 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingSubtract (Nat8)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: Nat8, rhs: Nat8): Nat8 is
            let result: Nat8 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingMultiply (Nat8)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: Nat8, rhs: Nat8): Nat8 is
            if rhs = 0 then
                Abort("Division by zero in trappingDivide (Nat8)");
            end if;
            return @embed(Nat8, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Int8) is
        method trappingAdd(lhs: Int8, rhs: Int8): Int8 is
            let result: Int8 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingAdd (Int8)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: Int8, rhs: Int8): Int8 is
            let result: Int8 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingSubtract (Int8)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: Int8, rhs: Int8): Int8 is
            let result: Int8 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingMultiply (Int8)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: Int8, rhs: Int8): Int8 is
            if rhs = 0 then
                Abort("Division by zero in trappingDivide (Int8)");
            end if;
            if (lhs = Minimum_Int8) and (rhs = -1) then
                Abort("Overflow in trappingDivide (Int8)");
            end if;
            return @embed(Int8, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Nat16) is
        method trappingAdd(lhs: Nat16, rhs: Nat16): Nat16 is
            let result: Nat16 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingAdd (Nat16)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: Nat16, rhs: Nat16): Nat16 is
            let result: Nat16 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingSubtract (Nat16)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: Nat16, rhs: Nat16): Nat16 is
            let result: Nat16 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingMultiply (Nat16)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: Nat16, rhs: Nat16): Nat16 is
            if rhs = 0 then
                Abort("Division by zero in trappingDivide (Nat16)");
            end if;
            return @embed(Nat16, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Int16) is
        method trappingAdd(lhs: Int16, rhs: Int16): Int16 is
            let result: Int16 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingAdd (Int16)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: Int16, rhs: Int16): Int16 is
            let result: Int16 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingSubtract (Int16)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: Int16, rhs: Int16): Int16 is
            let result: Int16 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingMultiply (Int16)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: Int16, rhs: Int16): Int16 is
            if rhs = 0 then
                Abort("Division by zero in trappingDivide (Int16)");
            end if;
            if (lhs = Minimum_Int16) and (rhs = -1) then
                Abort("Overflow in trappingDivide (Int16)");
            end if;
            return @embed(Int16, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Nat32) is
        method trappingAdd(lhs: Nat32, rhs: Nat32): Nat32 is
            let result: Nat32 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingAdd (Nat32)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: Nat32, rhs: Nat32): Nat32 is
            let result: Nat32 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingSubtract (Nat32)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: Nat32, rhs: Nat32): Nat32 is
            let result: Nat32 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingMultiply (Nat32)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: Nat32, rhs: Nat32): Nat32 is
            if rhs = 0 then
                Abort("Division by zero in trappingDivide (Nat32)");
            end if;
            return @embed(Nat32, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Int32) is
        method trappingAdd(lhs: Int32, rhs: Int32): Int32 is
            let result: Int32 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingAdd (Int32)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: Int32, rhs: Int32): Int32 is
            let result: Int32 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingSubtract (Int32)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: Int32, rhs: Int32): Int32 is
            let result: Int32 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingMultiply (Int32)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: Int32, rhs: Int32): Int32 is
            if rhs = 0 then
                Abort("Division by zero in trappingDivide (Int32)");
            end if;
            if (lhs = Minimum_Int32) and (rhs = -1) then
                Abort("Overflow in trappingDivide (Int32)");
            end if;
            return @embed(Int32, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Nat64) is
        method trappingAdd(lhs: Nat64, rhs: Nat64): Nat64 is
            let result: Nat64 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingAdd (Nat64)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: Nat64, rhs: Nat64): Nat64 is
            let result: Nat64 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingSubtract (Nat64)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: Nat64, rhs: Nat64): Nat64 is
            let result: Nat64 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingMultiply (Nat64)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: Nat64, rhs: Nat64): Nat64 is
            if rhs = 0 then
                Abort("Division by zero in trappingDivide (Nat64)");
            end if;
            return @embed(Nat64, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Int64) is
        method trappingAdd(lhs: Int64, rhs: Int64): Int64 is
            let result: Int64 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingAdd (Int64)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: Int64, rhs: Int64): Int64 is
            let result: Int64 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingSubtract (Int64)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: Int64, rhs: Int64): Int64 is
            let result: Int64 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingMultiply (Int64)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: Int64, rhs: Int64): Int64 is
            if rhs = 0 then
                Abort("Division by zero in trappingDivide (Int64)");
            end if;
            if (lhs = Minimum_Int64) and (rhs = -1) then
                Abort("Overflow in trappingDivide (Int64)");
            end if;
            return @embed(Int64, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Index) is
        method trappingAdd(lhs: Index, rhs: Index): Index is
            let result: Index := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingAdd (Index)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: Index, rhs: Index): Index is
            let result: Index := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingSubtract (Index)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: Index, rhs: Index): Index is
            let result: Index := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in trappingMultiply (Index)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: Index, rhs: Index): Index is
            if rhs = 0 then
                Abort("Division by zero in trappingDivide (Index)");
            end if;
            return @embed(Index, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Float64) is
        method trappingAdd(lhs: Float64, rhs: Float64): Float64 is
            return @embed(Float64, "$1 + $2", lhs, rhs);
        end;

        method trappingSubtract(lhs: Float64, rhs: Float64): Float64 is
            return @embed(Float64, "$1 - $2", lhs, rhs);
        end;

        method trappingMultiply(lhs: Float64, rhs: Float64): Float64 is
            return @embed(Float64, "$1 * $2", lhs, rhs);
        end;

        method trappingDivide(lhs: Float64, rhs: Float64): Float64 is
            if rhs = 0.0 then
                Abort("Division by zero in trappingDivide (Float64)");
            end if;
            return @embed(Float64, "$1 / $2", lhs, rhs);
        end;
    end;


    ---
    --- Modular Arithmetic
    ---

    instance ModularArithmetic(Nat8) is
        method modularAdd(lhs: Nat8, rhs: Nat8): Nat8 is
            return @embed(Nat8, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Nat8, rhs: Nat8): Nat8 is
            return @embed(Nat8, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Nat8, rhs: Nat8): Nat8 is
            return @embed(Nat8, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Nat8, rhs: Nat8): Nat8 is
            if rhs = 0 then
                Abort("Division by zero in modularDivide (Nat8)");
            end if;
            return @embed(Nat8, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Int8) is
        method modularAdd(lhs: Int8, rhs: Int8): Int8 is
            return @embed(Int8, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Int8, rhs: Int8): Int8 is
            return @embed(Int8, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Int8, rhs: Int8): Int8 is
            return @embed(Int8, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Int8, rhs: Int8): Int8 is
            if rhs = 0 then
                Abort("Division by zero in modularDivide (Int8)");
            end if;
            return @embed(Int8, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Nat16) is
        method modularAdd(lhs: Nat16, rhs: Nat16): Nat16 is
            return @embed(Nat16, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Nat16, rhs: Nat16): Nat16 is
            return @embed(Nat16, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Nat16, rhs: Nat16): Nat16 is
            return @embed(Nat16, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Nat16, rhs: Nat16): Nat16 is
            if rhs = 0 then
                Abort("Division by zero in modularDivide (Nat16)");
            end if;
            return @embed(Nat16, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Int16) is
        method modularAdd(lhs: Int16, rhs: Int16): Int16 is
            return @embed(Int16, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Int16, rhs: Int16): Int16 is
            return @embed(Int16, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Int16, rhs: Int16): Int16 is
            return @embed(Int16, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Int16, rhs: Int16): Int16 is
            if rhs = 0 then
                Abort("Division by zero in modularDivide (Int16)");
            end if;
            return @embed(Int16, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Nat32) is
        method modularAdd(lhs: Nat32, rhs: Nat32): Nat32 is
            return @embed(Nat32, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Nat32, rhs: Nat32): Nat32 is
            return @embed(Nat32, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Nat32, rhs: Nat32): Nat32 is
            return @embed(Nat32, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Nat32, rhs: Nat32): Nat32 is
            if rhs = 0 then
                Abort("Division by zero in modularDivide (Nat32)");
            end if;
            return @embed(Nat32, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Int32) is
        method modularAdd(lhs: Int32, rhs: Int32): Int32 is
            return @embed(Int32, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Int32, rhs: Int32): Int32 is
            return @embed(Int32, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Int32, rhs: Int32): Int32 is
            return @embed(Int32, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Int32, rhs: Int32): Int32 is
            if rhs = 0 then
                Abort("Division by zero in modularDivide (Int32)");
            end if;
            return @embed(Int32, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Nat64) is
        method modularAdd(lhs: Nat64, rhs: Nat64): Nat64 is
            return @embed(Nat64, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Nat64, rhs: Nat64): Nat64 is
            return @embed(Nat64, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Nat64, rhs: Nat64): Nat64 is
            return @embed(Nat64, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Nat64, rhs: Nat64): Nat64 is
            if rhs = 0 then
                Abort("Division by zero in modularDivide (Nat64)");
            end if;
            return @embed(Nat64, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Int64) is
        method modularAdd(lhs: Int64, rhs: Int64): Int64 is
            return @embed(Int64, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Int64, rhs: Int64): Int64 is
            return @embed(Int64, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Int64, rhs: Int64): Int64 is
            return @embed(Int64, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Int64, rhs: Int64): Int64 is
            if rhs = 0 then
                Abort("Division by zero in modularDivide (Int64)");
            end if;
            return @embed(Int64, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Index) is
        method modularAdd(lhs: Index, rhs: Index): Index is
            return @embed(Index, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Index, rhs: Index): Index is
            return @embed(Index, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Index, rhs: Index): Index is
            return @embed(Index, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Index, rhs: Index): Index is
            if rhs = 0 then
                Abort("Division by zero in modularDivide (Index)");
            end if;
            return @embed(Index, "$1 / $2", lhs, rhs);
        end;
    end;

    ---
    --- Printable
    ---

    instance Printable(Unit) is
        method print(value: Unit): Unit is
            return @embed(Unit, "au_printf(\"nil\")");
            return value;
        end;

        method printFixedArray(array: FixedArray[Unit]): Unit is
            return nil;
        end;
    end;

    instance Printable(Bool) is
        method print(value: Bool): Unit is
            if value then
                @embed(Unit, "au_printf(\"true\")");
            else
                @embed(Unit, "au_printf(\"false\")");
            end if;
            return nil;
        end;

        method printFixedArray(array: FixedArray[Unit]): Unit is
            return nil;
        end;
    end;

    instance Printable(Nat8) is
        method print(value: Nat8): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Nat8]): Unit is
            for i from 0 to Fixed_Array_Size(array) - 1 do
                @embed(Unit, "au_printf(\"%c\", $1)", array[i]);
            end for;
            return nil;
        end;
    end;

    instance Printable(Nat16) is
        method print(value: Nat16): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Nat16]): Unit is
            return nil;
        end;
    end;

    instance Printable(Nat32) is
        method print(value: Nat32): Unit is
            return @embed(Unit, "au_printf(\"%u\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Nat32]): Unit is
            return nil;
        end;
    end;

    instance Printable(Nat64) is
        method print(value: Nat64): Unit is
            return @embed(Unit, "au_printf(\"%zu\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Nat64]): Unit is
            return nil;
        end;
    end;

    instance Printable(Int8) is
        method print(value: Int8): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Int8]): Unit is
            return nil;
        end;
    end;

    instance Printable(Int16) is
        method print(value: Int16): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Int16]): Unit is
            return nil;
        end;
    end;

    instance Printable(Int32) is
        method print(value: Int32): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Int32]): Unit is
            return nil;
        end;
    end;

    instance Printable(Int64) is
        method print(value: Int64): Unit is
            return @embed(Unit, "au_printf(\"%li\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Int64]): Unit is
            return nil;
        end;
    end;

    instance Printable(Index) is
        method print(value: Index): Unit is
            return @embed(Unit, "au_printf(\"%zu\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Index]): Unit is
            return nil;
        end;
    end;

    instance Printable(Float32) is
        method print(value: Float32): Unit is
            return @embed(Unit, "au_printf(\"%f\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Float32]): Unit is
            return nil;
        end;
    end;

    instance Printable(Float64) is
        method print(value: Float64): Unit is
            return @embed(Unit, "au_printf(\"%f\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Float64]): Unit is
            return nil;
        end;
    end;

    generic [B: Free(Printable)]
    instance Printable(FixedArray[B]) is
        method print(value: FixedArray[B]): Unit is
            return printFixedArray(value);
        end;

        method printFixedArray(array: FixedArray[FixedArray[B]]): Unit is
            return nil;
        end;
    end;

    generic [T: Free(Printable)]
    function printLn(value: T): Unit is
        print(value);
        return @embed(Unit, "au_printf(\"\n\")");
    end;
end module body.