module body Austral.Pervasive is
    generic [T: Free, R: Region]
    function deref(ref: &[T, R]): T is
        return @embed(T, "*$1", ref);
    end;

    generic [T: Free, R: Region]
    function derefWrite(ref: &![T, R]): T is
        return @embed(T, "*$1", ref);
    end;

    generic [T: Type]
    function fixedArraySize(arr: FixedArray[T]): Index is
        return @embed(Index, "$1.size", arr);
    end;

    function abort(message: FixedArray[Nat8]): Unit is
        return @embed(Unit, "au_abort($1)", message);
    end;

    record RootCapability: Linear is
        value: Unit;
    end;

    function surrenderRoot(cap: RootCapability): Unit is
        let { value: Unit } := cap;
        return nil;
    end;

    function argumentCount(): Index is
        return @embed(Index, "au_get_argc()");
    end;

    function nthArgument(n: Index): FixedArray[Nat8] is
        return @embed(FixedArray[Nat8], "au_get_nth_arg($1)", n);
    end;

    constant minimum_nat8: Int8 := 0;
    constant maximum_nat8: Nat8 := @embed(Nat8, "UINT8_MAX");

    constant minimum_nat16: Int8 := 0;
    constant maximum_nat16: Nat16 := @embed(Nat16, "UINT16_MAX");

    constant minimum_nat32: Int8 := 0;
    constant maximum_nat32: Nat32 := @embed(Nat32, "UINT32_MAX");

    constant minimum_nat64: Int8 := 0;
    constant maximum_nat64: Nat64 := @embed(Nat64, "UINT64_MAX");

    constant minimum_int8: Int8 := @embed(Int8, "INT8_MIN");
    constant maximum_int8: Int8 := @embed(Int8, "INT8_MAX");

    constant minimum_int16: Int16 := @embed(Int16, "INT16_MIN");
    constant maximum_int16: Int16 := @embed(Int16, "INT16_MAX");

    constant minimum_int32: Int32 := @embed(Int32, "INT32_MIN");
    constant maximum_int32: Int32 := @embed(Int32, "INT32_MAX");

    constant minimum_int64: Int64 := @embed(Int64, "INT64_MIN");
    constant maximum_int64: Int64 := @embed(Int64, "INT64_MAX");

    constant minimum_index: Index := 0;
    constant maximum_index: Index := @embed(Index, "SIZE_MAX");

    constant minimum_bytesize: ByteSize := 0;
    constant maximum_bytesize: ByteSize := @embed(ByteSize, "SIZE_MAX");

    ---
    --- Trapping Arithmetic
    ---

    function badOp(msg: FixedArray[Nat8], typ: FixedArray[Nat8]): Unit is
        @embed(Unit, "au_print_error((char*)$1.data)", typ);
        @embed(Unit, "au_print_error(\": \")");
        abort(msg);
    end;

    generic [T: Free]
    function trappingAddGen(typ: FixedArray[Nat8], lhs: T, rhs: T): T is
        let result: T := lhs;
        let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
        if did_overflow then
            badOp("Overflow in trappingAdd", typ);
        end if;
        return result;
    end;

    generic [T: Free]
    function trappingSubtractGen(typ: FixedArray[Nat8], lhs: T, rhs: T): T is
        let result: T := lhs;
        let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
        if did_overflow then
            badOp("Overflow in trappingSubtract", typ);
        end if;
        return result;
    end;


    generic [T: Free]
    function trappingMultiplyGen(typ: FixedArray[Nat8], lhs: T, rhs: T): T is
        let result: T := lhs;
        let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
        if did_overflow then
            badOp("Overflow in trappingMultiply", typ);
        end if;
        return result;
    end;

    generic [T: Free]
    function trappingDivideGen(typ: FixedArray[Nat8], lhs: T, rhs: T): T is
        if rhs = 0 then
            badOp("Division by zero in trappingDivide", typ);
        end if;
        return @embed(T, "$1 / $2", lhs, rhs);
    end;

    generic [T: Free]
    function trappingSignedDivideGen(typ: FixedArray[Nat8], mint: T, lhs: T, rhs: T): T is
        if rhs = 0 then
            badOp("Division by zero in trappingDivide", typ);
        end if;
        if (lhs = mint) and (rhs =  -1) then
            badOp("Overflow in trappingDivide", typ);
        end if;
        return @embed(T, "$1 / $2", lhs, rhs);
    end;


    instance TrappingArithmetic(Nat8) is
        method trappingAdd(lhs: Nat8, rhs: Nat8): Nat8 is
            return trappingAddGen("Nat8", lhs, rhs);
        end;

        method trappingSubtract(lhs: Nat8, rhs: Nat8): Nat8 is
            return trappingSubtractGen("Nat8", lhs, rhs);
        end;

        method trappingMultiply(lhs: Nat8, rhs: Nat8): Nat8 is
            return trappingMultiplyGen("Nat8", lhs, rhs);
        end;

        method trappingDivide(lhs: Nat8, rhs: Nat8): Nat8 is
            return trappingDivideGen("Nat8", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Int8) is
        method trappingAdd(lhs: Int8, rhs: Int8): Int8 is
            return trappingAddGen("Int8", lhs, rhs);
        end;

        method trappingSubtract(lhs: Int8, rhs: Int8): Int8 is
            return trappingSubtractGen("Int8", lhs, rhs);
        end;

        method trappingMultiply(lhs: Int8, rhs: Int8): Int8 is
            return trappingMultiplyGen("Int8", lhs, rhs);
        end;

        method trappingDivide(lhs: Int8, rhs: Int8): Int8 is
            return trappingSignedDivideGen("Int8", minimum_int8, lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Nat16) is
        method trappingAdd(lhs: Nat16, rhs: Nat16): Nat16 is
            return trappingAddGen("Nat16", lhs, rhs);
        end;

        method trappingSubtract(lhs: Nat16, rhs: Nat16): Nat16 is
            return trappingSubtractGen("Nat8", lhs, rhs);
        end;

        method trappingMultiply(lhs: Nat16, rhs: Nat16): Nat16 is
            return trappingMultiplyGen("Nat16", lhs, rhs);
        end;

        method trappingDivide(lhs: Nat16, rhs: Nat16): Nat16 is
            return trappingDivideGen("Nat16", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Int16) is
        method trappingAdd(lhs: Int16, rhs: Int16): Int16 is
            return trappingAddGen("Int16", lhs, rhs);
        end;

        method trappingSubtract(lhs: Int16, rhs: Int16): Int16 is
            return trappingSubtractGen("Int16", lhs, rhs);
        end;

        method trappingMultiply(lhs: Int16, rhs: Int16): Int16 is
            return trappingMultiplyGen("Int16", lhs, rhs);
        end;

        method trappingDivide(lhs: Int16, rhs: Int16): Int16 is
            return trappingSignedDivideGen("Int16", minimum_int16, lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Nat32) is
        method trappingAdd(lhs: Nat32, rhs: Nat32): Nat32 is
            return trappingAddGen("Nat32", lhs, rhs);
        end;

        method trappingSubtract(lhs: Nat32, rhs: Nat32): Nat32 is
            return trappingSubtractGen("Nat32", lhs, rhs);
        end;

        method trappingMultiply(lhs: Nat32, rhs: Nat32): Nat32 is
            return trappingMultiplyGen("Nat32", lhs, rhs);
        end;

        method trappingDivide(lhs: Nat32, rhs: Nat32): Nat32 is
            return trappingDivideGen("Nat32", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Int32) is
        method trappingAdd(lhs: Int32, rhs: Int32): Int32 is
            return trappingAddGen("Int32", lhs, rhs);
        end;

        method trappingSubtract(lhs: Int32, rhs: Int32): Int32 is
            return trappingSubtractGen("Int32", lhs, rhs);
        end;

        method trappingMultiply(lhs: Int32, rhs: Int32): Int32 is
            return trappingMultiplyGen("Int32", lhs, rhs);
        end;

        method trappingDivide(lhs: Int32, rhs: Int32): Int32 is
            return trappingSignedDivideGen("Int32", minimum_int32, lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Nat64) is
        method trappingAdd(lhs: Nat64, rhs: Nat64): Nat64 is
            return trappingAddGen("Nat64", lhs, rhs);
        end;

        method trappingSubtract(lhs: Nat64, rhs: Nat64): Nat64 is
            return trappingSubtractGen("Nat64", lhs, rhs);
        end;

        method trappingMultiply(lhs: Nat64, rhs: Nat64): Nat64 is
            return trappingMultiplyGen("Nat64", lhs, rhs);
        end;

        method trappingDivide(lhs: Nat64, rhs: Nat64): Nat64 is
            return trappingDivideGen("Nat64", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Int64) is
        method trappingAdd(lhs: Int64, rhs: Int64): Int64 is
            return trappingAddGen("Int64", lhs, rhs);
        end;

        method trappingSubtract(lhs: Int64, rhs: Int64): Int64 is
            return trappingSubtractGen("Int64", lhs, rhs);
        end;

        method trappingMultiply(lhs: Int64, rhs: Int64): Int64 is
            return trappingMultiplyGen("Int64", lhs, rhs);
        end;

        method trappingDivide(lhs: Int64, rhs: Int64): Int64 is
            return trappingSignedDivideGen("Int64", minimum_int64, lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Index) is
        method trappingAdd(lhs: Index, rhs: Index): Index is
            return trappingAddGen("Index", lhs, rhs);
        end;

        method trappingSubtract(lhs: Index, rhs: Index): Index is
            return trappingSubtractGen("Index", lhs, rhs);
        end;

        method trappingMultiply(lhs: Index, rhs: Index): Index is
            return trappingMultiplyGen("Index", lhs, rhs);
        end;

        method trappingDivide(lhs: Index, rhs: Index): Index is
            return trappingDivideGen("Index", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(ByteSize) is
        method trappingAdd(lhs: ByteSize, rhs: ByteSize): ByteSize is
            return trappingAddGen("ByteSize", lhs, rhs);
        end;

        method trappingSubtract(lhs: ByteSize, rhs: ByteSize): ByteSize is
            return trappingSubtractGen("ByteSize", lhs, rhs);
        end;

        method trappingMultiply(lhs: ByteSize, rhs: ByteSize): ByteSize is
            return trappingMultiplyGen("ByteSize", lhs, rhs);
        end;

        method trappingDivide(lhs: ByteSize, rhs: ByteSize): ByteSize is
            return trappingDivideGen("ByteSize", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Float64) is
        method trappingAdd(lhs: Float64, rhs: Float64): Float64 is
            return @embed(Float64, "$1 + $2", lhs, rhs);
        end;

        method trappingSubtract(lhs: Float64, rhs: Float64): Float64 is
            return @embed(Float64, "$1 - $2", lhs, rhs);
        end;

        method trappingMultiply(lhs: Float64, rhs: Float64): Float64 is
            return @embed(Float64, "$1 * $2", lhs, rhs);
        end;

        method trappingDivide(lhs: Float64, rhs: Float64): Float64 is
            if rhs = 0.0 then
                abort("Division by zero in trappingDivide (Float64)");
            end if;
            return @embed(Float64, "$1 / $2", lhs, rhs);
        end;
    end;


    ---
    --- Modular Arithmetic
    ---

    instance ModularArithmetic(Nat8) is
        method modularAdd(lhs: Nat8, rhs: Nat8): Nat8 is
            return @embed(Nat8, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Nat8, rhs: Nat8): Nat8 is
            return @embed(Nat8, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Nat8, rhs: Nat8): Nat8 is
            return @embed(Nat8, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Nat8, rhs: Nat8): Nat8 is
            if rhs = 0 then
                abort("Division by zero in modularDivide (Nat8)");
            end if;
            return @embed(Nat8, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Int8) is
        method modularAdd(lhs: Int8, rhs: Int8): Int8 is
            return @embed(Int8, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Int8, rhs: Int8): Int8 is
            return @embed(Int8, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Int8, rhs: Int8): Int8 is
            return @embed(Int8, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Int8, rhs: Int8): Int8 is
            if rhs = 0 then
                abort("Division by zero in modularDivide (Int8)");
            end if;
            return @embed(Int8, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Nat16) is
        method modularAdd(lhs: Nat16, rhs: Nat16): Nat16 is
            return @embed(Nat16, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Nat16, rhs: Nat16): Nat16 is
            return @embed(Nat16, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Nat16, rhs: Nat16): Nat16 is
            return @embed(Nat16, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Nat16, rhs: Nat16): Nat16 is
            if rhs = 0 then
                abort("Division by zero in modularDivide (Nat16)");
            end if;
            return @embed(Nat16, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Int16) is
        method modularAdd(lhs: Int16, rhs: Int16): Int16 is
            return @embed(Int16, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Int16, rhs: Int16): Int16 is
            return @embed(Int16, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Int16, rhs: Int16): Int16 is
            return @embed(Int16, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Int16, rhs: Int16): Int16 is
            if rhs = 0 then
                abort("Division by zero in modularDivide (Int16)");
            end if;
            return @embed(Int16, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Nat32) is
        method modularAdd(lhs: Nat32, rhs: Nat32): Nat32 is
            return @embed(Nat32, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Nat32, rhs: Nat32): Nat32 is
            return @embed(Nat32, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Nat32, rhs: Nat32): Nat32 is
            return @embed(Nat32, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Nat32, rhs: Nat32): Nat32 is
            if rhs = 0 then
                abort("Division by zero in modularDivide (Nat32)");
            end if;
            return @embed(Nat32, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Int32) is
        method modularAdd(lhs: Int32, rhs: Int32): Int32 is
            return @embed(Int32, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Int32, rhs: Int32): Int32 is
            return @embed(Int32, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Int32, rhs: Int32): Int32 is
            return @embed(Int32, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Int32, rhs: Int32): Int32 is
            if rhs = 0 then
                abort("Division by zero in modularDivide (Int32)");
            end if;
            return @embed(Int32, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Nat64) is
        method modularAdd(lhs: Nat64, rhs: Nat64): Nat64 is
            return @embed(Nat64, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Nat64, rhs: Nat64): Nat64 is
            return @embed(Nat64, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Nat64, rhs: Nat64): Nat64 is
            return @embed(Nat64, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Nat64, rhs: Nat64): Nat64 is
            if rhs = 0 then
                abort("Division by zero in modularDivide (Nat64)");
            end if;
            return @embed(Nat64, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Int64) is
        method modularAdd(lhs: Int64, rhs: Int64): Int64 is
            return @embed(Int64, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Int64, rhs: Int64): Int64 is
            return @embed(Int64, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Int64, rhs: Int64): Int64 is
            return @embed(Int64, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Int64, rhs: Int64): Int64 is
            if rhs = 0 then
                abort("Division by zero in modularDivide (Int64)");
            end if;
            return @embed(Int64, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Index) is
        method modularAdd(lhs: Index, rhs: Index): Index is
            return @embed(Index, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Index, rhs: Index): Index is
            return @embed(Index, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Index, rhs: Index): Index is
            return @embed(Index, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Index, rhs: Index): Index is
            if rhs = 0 then
                abort("Division by zero in modularDivide (Index)");
            end if;
            return @embed(Index, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(ByteSize) is
        method modularAdd(lhs: ByteSize, rhs: ByteSize): ByteSize is
            return @embed(ByteSize, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: ByteSize, rhs: ByteSize): ByteSize is
            return @embed(ByteSize, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: ByteSize, rhs: ByteSize): ByteSize is
            return @embed(ByteSize, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: ByteSize, rhs: ByteSize): ByteSize is
            if rhs = 0 then
                abort("Division by zero in modularDivide (ByteSize)");
            end if;
            return @embed(ByteSize, "$1 / $2", lhs, rhs);
        end;
    end;

    ---
    --- Printable
    ---

    instance Printable(Unit) is
        method print(value: Unit): Unit is
            return @embed(Unit, "au_printf(\"nil\")");
            return value;
        end;

        method printFixedArray(array: FixedArray[Unit]): Unit is
            return nil;
        end;
    end;

    instance Printable(Bool) is
        method print(value: Bool): Unit is
            if value then
                @embed(Unit, "au_printf(\"true\")");
            else
                @embed(Unit, "au_printf(\"false\")");
            end if;
            return nil;
        end;

        method printFixedArray(array: FixedArray[Unit]): Unit is
            return nil;
        end;
    end;

    instance Printable(Nat8) is
        method print(value: Nat8): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Nat8]): Unit is
            for i from 0 to fixedArraySize(array) - 1 do
                @embed(Unit, "au_printf(\"%c\", $1)", array[i]);
            end for;
            return nil;
        end;
    end;

    instance Printable(Nat16) is
        method print(value: Nat16): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Nat16]): Unit is
            return nil;
        end;
    end;

    instance Printable(Nat32) is
        method print(value: Nat32): Unit is
            return @embed(Unit, "au_printf(\"%u\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Nat32]): Unit is
            return nil;
        end;
    end;

    instance Printable(Nat64) is
        method print(value: Nat64): Unit is
            return @embed(Unit, "au_printf(\"%zu\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Nat64]): Unit is
            return nil;
        end;
    end;

    instance Printable(Int8) is
        method print(value: Int8): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Int8]): Unit is
            return nil;
        end;
    end;

    instance Printable(Int16) is
        method print(value: Int16): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Int16]): Unit is
            return nil;
        end;
    end;

    instance Printable(Int32) is
        method print(value: Int32): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Int32]): Unit is
            return nil;
        end;
    end;

    instance Printable(Int64) is
        method print(value: Int64): Unit is
            return @embed(Unit, "au_printf(\"%li\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Int64]): Unit is
            return nil;
        end;
    end;

    instance Printable(Index) is
        method print(value: Index): Unit is
            return @embed(Unit, "au_printf(\"%zu\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Index]): Unit is
            return nil;
        end;
    end;

    instance Printable(ByteSize) is
        method print(value: ByteSize): Unit is
            return @embed(Unit, "au_printf(\"%zu\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[ByteSize]): Unit is
            return nil;
        end;
    end;

    instance Printable(Float32) is
        method print(value: Float32): Unit is
            return @embed(Unit, "au_printf(\"%f\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Float32]): Unit is
            return nil;
        end;
    end;

    instance Printable(Float64) is
        method print(value: Float64): Unit is
            return @embed(Unit, "au_printf(\"%f\", $1)", value);
            return nil;
        end;

        method printFixedArray(array: FixedArray[Float64]): Unit is
            return nil;
        end;
    end;

    generic [B: Free(Printable)]
    instance Printable(FixedArray[B]) is
        method print(value: FixedArray[B]): Unit is
            return printFixedArray(value);
        end;

        method printFixedArray(array: FixedArray[FixedArray[B]]): Unit is
            return nil;
        end;
    end;

    generic [T: Free(Printable)]
    function printLn(value: T): Unit is
        print(value);
        return @embed(Unit, "au_printf(\"\n\")");
    end;
end module body.