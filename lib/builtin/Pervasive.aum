module body Austral.Pervasive is
    generic [T: Free, R: Region]
    function Deref(ref: &[T, R]): T is
        return @embed(T, "*$1", ref);
    end;

    generic [T: Free, R: Region]
    function Deref_Write(ref: &![T, R]): T is
        return @embed(T, "*$1", ref);
    end;

    generic [T: Type]
    function Fixed_Array_Size(arr: Fixed_Array[T]): Index is
        return @embed(Index, "$1.size", arr);
    end;

    function Abort(message: Fixed_Array[Nat8]): Unit is
        return @embed(Unit, "au_abort($1)", message);
    end;

    record RootCapability: Linear is
        value: Unit;
    end;

    constant Minimum_Nat8: Int8 := 0;
    constant Maximum_Nat8: Nat8 := @embed(Nat8, "UINT8_MAX");

    constant Minimum_Nat16: Int8 := 0;
    constant Maximum_Nat16: Nat16 := @embed(Nat16, "UINT16_MAX");

    constant Minimum_Nat32: Int8 := 0;
    constant Maximum_Nat32: Nat32 := @embed(Nat32, "UINT32_MAX");

    constant Minimum_Nat64: Int8 := 0;
    constant Maximum_Nat64: Nat64 := @embed(Nat64, "UINT64_MAX");

    constant Minimum_Int8: Int8 := @embed(Int8, "INT8_MIN");
    constant Maximum_Int8: Int8 := @embed(Int8, "INT8_MAX");

    constant Minimum_Int16: Int16 := @embed(Int16, "INT16_MIN");
    constant Maximum_Int16: Int16 := @embed(Int16, "INT16_MAX");

    constant Minimum_Int32: Int32 := @embed(Int32, "INT32_MIN");
    constant Maximum_Int32: Int32 := @embed(Int32, "INT32_MAX");

    constant Minimum_Int64: Int64 := @embed(Int64, "INT64_MIN");
    constant Maximum_Int64: Int64 := @embed(Int64, "INT64_MAX");

    constant Minimum_Index: Index := 0;
    constant Maximum_Index: Index := @embed(Index, "SIZE_MAX");

    ---
    --- Trapping Arithmetic
    ---

    instance Trapping_Arithmetic(Nat8) is
        method Trapping_Add(lhs: Nat8, rhs: Nat8): Nat8 is
            let result: Nat8 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Add (Nat8)");
            end if;
            return result;
        end;

        method Trapping_Subtract(lhs: Nat8, rhs: Nat8): Nat8 is
            let result: Nat8 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Subtract (Nat8)");
            end if;
            return result;
        end;

        method Trapping_Multiply(lhs: Nat8, rhs: Nat8): Nat8 is
            let result: Nat8 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Multiply (Nat8)");
            end if;
            return result;
        end;

        method Trapping_Divide(lhs: Nat8, rhs: Nat8): Nat8 is
            if rhs = 0 then
                Abort("Division by zero in Trapping_Divide (Nat8)");
            end if;
            return @embed(Nat8, "$1 / $2", lhs, rhs);
        end;
    end;

    instance Trapping_Arithmetic(Int8) is
        method Trapping_Add(lhs: Int8, rhs: Int8): Int8 is
            let result: Int8 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Add (Int8)");
            end if;
            return result;
        end;

        method Trapping_Subtract(lhs: Int8, rhs: Int8): Int8 is
            let result: Int8 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Subtract (Int8)");
            end if;
            return result;
        end;

        method Trapping_Multiply(lhs: Int8, rhs: Int8): Int8 is
            let result: Int8 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Multiply (Int8)");
            end if;
            return result;
        end;

        method Trapping_Divide(lhs: Int8, rhs: Int8): Int8 is
            if rhs = 0 then
                Abort("Division by zero in Trapping_Divide (Int8)");
            end if;
            if (lhs = Minimum_Int8) and (rhs = -1) then
                Abort("Overflow in Trapping_Divide (Int8)");
            end if;
            return @embed(Int8, "$1 / $2", lhs, rhs);
        end;
    end;

    instance Trapping_Arithmetic(Nat16) is
        method Trapping_Add(lhs: Nat16, rhs: Nat16): Nat16 is
            let result: Nat16 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Add (Nat16)");
            end if;
            return result;
        end;

        method Trapping_Subtract(lhs: Nat16, rhs: Nat16): Nat16 is
            let result: Nat16 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Subtract (Nat16)");
            end if;
            return result;
        end;

        method Trapping_Multiply(lhs: Nat16, rhs: Nat16): Nat16 is
            let result: Nat16 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Multiply (Nat16)");
            end if;
            return result;
        end;

        method Trapping_Divide(lhs: Nat16, rhs: Nat16): Nat16 is
            if rhs = 0 then
                Abort("Division by zero in Trapping_Divide (Nat16)");
            end if;
            return @embed(Nat16, "$1 / $2", lhs, rhs);
        end;
    end;

    instance Trapping_Arithmetic(Int16) is
        method Trapping_Add(lhs: Int16, rhs: Int16): Int16 is
            let result: Int16 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Add (Int16)");
            end if;
            return result;
        end;

        method Trapping_Subtract(lhs: Int16, rhs: Int16): Int16 is
            let result: Int16 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Subtract (Int16)");
            end if;
            return result;
        end;

        method Trapping_Multiply(lhs: Int16, rhs: Int16): Int16 is
            let result: Int16 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Multiply (Int16)");
            end if;
            return result;
        end;

        method Trapping_Divide(lhs: Int16, rhs: Int16): Int16 is
            if rhs = 0 then
                Abort("Division by zero in Trapping_Divide (Int16)");
            end if;
            if (lhs = Minimum_Int16) and (rhs = -1) then
                Abort("Overflow in Trapping_Divide (Int16)");
            end if;
            return @embed(Int16, "$1 / $2", lhs, rhs);
        end;
    end;

    instance Trapping_Arithmetic(Nat32) is
        method Trapping_Add(lhs: Nat32, rhs: Nat32): Nat32 is
            let result: Nat32 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Add (Nat32)");
            end if;
            return result;
        end;

        method Trapping_Subtract(lhs: Nat32, rhs: Nat32): Nat32 is
            let result: Nat32 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Subtract (Nat32)");
            end if;
            return result;
        end;

        method Trapping_Multiply(lhs: Nat32, rhs: Nat32): Nat32 is
            let result: Nat32 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Multiply (Nat32)");
            end if;
            return result;
        end;

        method Trapping_Divide(lhs: Nat32, rhs: Nat32): Nat32 is
            if rhs = 0 then
                Abort("Division by zero in Trapping_Divide (Nat32)");
            end if;
            return @embed(Nat32, "$1 / $2", lhs, rhs);
        end;
    end;

    instance Trapping_Arithmetic(Int32) is
        method Trapping_Add(lhs: Int32, rhs: Int32): Int32 is
            let result: Int32 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Add (Int32)");
            end if;
            return result;
        end;

        method Trapping_Subtract(lhs: Int32, rhs: Int32): Int32 is
            let result: Int32 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Subtract (Int32)");
            end if;
            return result;
        end;

        method Trapping_Multiply(lhs: Int32, rhs: Int32): Int32 is
            let result: Int32 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Multiply (Int32)");
            end if;
            return result;
        end;

        method Trapping_Divide(lhs: Int32, rhs: Int32): Int32 is
            if rhs = 0 then
                Abort("Division by zero in Trapping_Divide (Int32)");
            end if;
            if (lhs = Minimum_Int32) and (rhs = -1) then
                Abort("Overflow in Trapping_Divide (Int32)");
            end if;
            return @embed(Int32, "$1 / $2", lhs, rhs);
        end;
    end;

    instance Trapping_Arithmetic(Nat64) is
        method Trapping_Add(lhs: Nat64, rhs: Nat64): Nat64 is
            let result: Nat64 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Add (Nat64)");
            end if;
            return result;
        end;

        method Trapping_Subtract(lhs: Nat64, rhs: Nat64): Nat64 is
            let result: Nat64 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Subtract (Nat64)");
            end if;
            return result;
        end;

        method Trapping_Multiply(lhs: Nat64, rhs: Nat64): Nat64 is
            let result: Nat64 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Multiply (Nat64)");
            end if;
            return result;
        end;

        method Trapping_Divide(lhs: Nat64, rhs: Nat64): Nat64 is
            if rhs = 0 then
                Abort("Division by zero in Trapping_Divide (Nat64)");
            end if;
            return @embed(Nat64, "$1 / $2", lhs, rhs);
        end;
    end;

    instance Trapping_Arithmetic(Int64) is
        method Trapping_Add(lhs: Int64, rhs: Int64): Int64 is
            let result: Int64 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Add (Int64)");
            end if;
            return result;
        end;

        method Trapping_Subtract(lhs: Int64, rhs: Int64): Int64 is
            let result: Int64 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Subtract (Int64)");
            end if;
            return result;
        end;

        method Trapping_Multiply(lhs: Int64, rhs: Int64): Int64 is
            let result: Int64 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Multiply (Int64)");
            end if;
            return result;
        end;

        method Trapping_Divide(lhs: Int64, rhs: Int64): Int64 is
            if rhs = 0 then
                Abort("Division by zero in Trapping_Divide (Int64)");
            end if;
            if (lhs = Minimum_Int64) and (rhs = -1) then
                Abort("Overflow in Trapping_Divide (Int64)");
            end if;
            return @embed(Int64, "$1 / $2", lhs, rhs);
        end;
    end;

    instance Trapping_Arithmetic(Index) is
        method Trapping_Add(lhs: Index, rhs: Index): Index is
            let result: Index := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Add (Index)");
            end if;
            return result;
        end;

        method Trapping_Subtract(lhs: Index, rhs: Index): Index is
            let result: Index := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Subtract (Index)");
            end if;
            return result;
        end;

        method Trapping_Multiply(lhs: Index, rhs: Index): Index is
            let result: Index := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                Abort("Overflow in Trapping_Multiply (Index)");
            end if;
            return result;
        end;

        method Trapping_Divide(lhs: Index, rhs: Index): Index is
            if rhs = 0 then
                Abort("Division by zero in Trapping_Divide (Index)");
            end if;
            return @embed(Index, "$1 / $2", lhs, rhs);
        end;
    end;

    instance Trapping_Arithmetic(Float64) is
        method Trapping_Add(lhs: Float64, rhs: Float64): Float64 is
            return @embed(Float64, "$1 + $2", lhs, rhs);
        end;

        method Trapping_Subtract(lhs: Float64, rhs: Float64): Float64 is
            return @embed(Float64, "$1 - $2", lhs, rhs);
        end;

        method Trapping_Multiply(lhs: Float64, rhs: Float64): Float64 is
            return @embed(Float64, "$1 * $2", lhs, rhs);
        end;

        method Trapping_Divide(lhs: Float64, rhs: Float64): Float64 is
            if rhs = 0.0 then
                Abort("Division by zero in Trapping_Divide (Float64)");
            end if;
            return @embed(Float64, "$1 / $2", lhs, rhs);
        end;
    end;


    ---
    --- Modular Arithmetic
    ---

    instance Modular_Arithmetic(Nat8) is
        method Modular_Add(lhs: Nat8, rhs: Nat8): Nat8 is
            return @embed(Nat8, "$1 + $2", lhs, rhs);
        end;

        method Modular_Subtract(lhs: Nat8, rhs: Nat8): Nat8 is
            return @embed(Nat8, "$1 - $2", lhs, rhs);
        end;

        method Modular_Multiply(lhs: Nat8, rhs: Nat8): Nat8 is
            return @embed(Nat8, "$1 * $2", lhs, rhs);
        end;

        method Modular_Divide(lhs: Nat8, rhs: Nat8): Nat8 is
            if rhs = 0 then
                Abort("Division by zero in Modular_Divide (Nat8)");
            end if;
            return @embed(Nat8, "$1 / $2", lhs, rhs);
        end;
    end;

    instance Modular_Arithmetic(Int8) is
        method Modular_Add(lhs: Int8, rhs: Int8): Int8 is
            return @embed(Int8, "$1 + $2", lhs, rhs);
        end;

        method Modular_Subtract(lhs: Int8, rhs: Int8): Int8 is
            return @embed(Int8, "$1 - $2", lhs, rhs);
        end;

        method Modular_Multiply(lhs: Int8, rhs: Int8): Int8 is
            return @embed(Int8, "$1 * $2", lhs, rhs);
        end;

        method Modular_Divide(lhs: Int8, rhs: Int8): Int8 is
            if rhs = 0 then
                Abort("Division by zero in Modular_Divide (Int8)");
            end if;
            return @embed(Int8, "$1 / $2", lhs, rhs);
        end;
    end;

    instance Modular_Arithmetic(Nat16) is
        method Modular_Add(lhs: Nat16, rhs: Nat16): Nat16 is
            return @embed(Nat16, "$1 + $2", lhs, rhs);
        end;

        method Modular_Subtract(lhs: Nat16, rhs: Nat16): Nat16 is
            return @embed(Nat16, "$1 - $2", lhs, rhs);
        end;

        method Modular_Multiply(lhs: Nat16, rhs: Nat16): Nat16 is
            return @embed(Nat16, "$1 * $2", lhs, rhs);
        end;

        method Modular_Divide(lhs: Nat16, rhs: Nat16): Nat16 is
            if rhs = 0 then
                Abort("Division by zero in Modular_Divide (Nat16)");
            end if;
            return @embed(Nat16, "$1 / $2", lhs, rhs);
        end;
    end;

    instance Modular_Arithmetic(Int16) is
        method Modular_Add(lhs: Int16, rhs: Int16): Int16 is
            return @embed(Int16, "$1 + $2", lhs, rhs);
        end;

        method Modular_Subtract(lhs: Int16, rhs: Int16): Int16 is
            return @embed(Int16, "$1 - $2", lhs, rhs);
        end;

        method Modular_Multiply(lhs: Int16, rhs: Int16): Int16 is
            return @embed(Int16, "$1 * $2", lhs, rhs);
        end;

        method Modular_Divide(lhs: Int16, rhs: Int16): Int16 is
            if rhs = 0 then
                Abort("Division by zero in Modular_Divide (Int16)");
            end if;
            return @embed(Int16, "$1 / $2", lhs, rhs);
        end;
    end;

    instance Modular_Arithmetic(Nat32) is
        method Modular_Add(lhs: Nat32, rhs: Nat32): Nat32 is
            return @embed(Nat32, "$1 + $2", lhs, rhs);
        end;

        method Modular_Subtract(lhs: Nat32, rhs: Nat32): Nat32 is
            return @embed(Nat32, "$1 - $2", lhs, rhs);
        end;

        method Modular_Multiply(lhs: Nat32, rhs: Nat32): Nat32 is
            return @embed(Nat32, "$1 * $2", lhs, rhs);
        end;

        method Modular_Divide(lhs: Nat32, rhs: Nat32): Nat32 is
            if rhs = 0 then
                Abort("Division by zero in Modular_Divide (Nat32)");
            end if;
            return @embed(Nat32, "$1 / $2", lhs, rhs);
        end;
    end;

    instance Modular_Arithmetic(Int32) is
        method Modular_Add(lhs: Int32, rhs: Int32): Int32 is
            return @embed(Int32, "$1 + $2", lhs, rhs);
        end;

        method Modular_Subtract(lhs: Int32, rhs: Int32): Int32 is
            return @embed(Int32, "$1 - $2", lhs, rhs);
        end;

        method Modular_Multiply(lhs: Int32, rhs: Int32): Int32 is
            return @embed(Int32, "$1 * $2", lhs, rhs);
        end;

        method Modular_Divide(lhs: Int32, rhs: Int32): Int32 is
            if rhs = 0 then
                Abort("Division by zero in Modular_Divide (Int32)");
            end if;
            return @embed(Int32, "$1 / $2", lhs, rhs);
        end;
    end;

    instance Modular_Arithmetic(Nat64) is
        method Modular_Add(lhs: Nat64, rhs: Nat64): Nat64 is
            return @embed(Nat64, "$1 + $2", lhs, rhs);
        end;

        method Modular_Subtract(lhs: Nat64, rhs: Nat64): Nat64 is
            return @embed(Nat64, "$1 - $2", lhs, rhs);
        end;

        method Modular_Multiply(lhs: Nat64, rhs: Nat64): Nat64 is
            return @embed(Nat64, "$1 * $2", lhs, rhs);
        end;

        method Modular_Divide(lhs: Nat64, rhs: Nat64): Nat64 is
            if rhs = 0 then
                Abort("Division by zero in Modular_Divide (Nat64)");
            end if;
            return @embed(Nat64, "$1 / $2", lhs, rhs);
        end;
    end;

    instance Modular_Arithmetic(Int64) is
        method Modular_Add(lhs: Int64, rhs: Int64): Int64 is
            return @embed(Int64, "$1 + $2", lhs, rhs);
        end;

        method Modular_Subtract(lhs: Int64, rhs: Int64): Int64 is
            return @embed(Int64, "$1 - $2", lhs, rhs);
        end;

        method Modular_Multiply(lhs: Int64, rhs: Int64): Int64 is
            return @embed(Int64, "$1 * $2", lhs, rhs);
        end;

        method Modular_Divide(lhs: Int64, rhs: Int64): Int64 is
            if rhs = 0 then
                Abort("Division by zero in Modular_Divide (Int64)");
            end if;
            return @embed(Int64, "$1 / $2", lhs, rhs);
        end;
    end;

    instance Modular_Arithmetic(Index) is
        method Modular_Add(lhs: Index, rhs: Index): Index is
            return @embed(Index, "$1 + $2", lhs, rhs);
        end;

        method Modular_Subtract(lhs: Index, rhs: Index): Index is
            return @embed(Index, "$1 - $2", lhs, rhs);
        end;

        method Modular_Multiply(lhs: Index, rhs: Index): Index is
            return @embed(Index, "$1 * $2", lhs, rhs);
        end;

        method Modular_Divide(lhs: Index, rhs: Index): Index is
            if rhs = 0 then
                Abort("Division by zero in Modular_Divide (Index)");
            end if;
            return @embed(Index, "$1 / $2", lhs, rhs);
        end;
    end;

    ---
    --- Printable
    ---

    instance Printable(Unit) is
        method Print(value: Unit): Unit is
            return @embed(Unit, "au_printf(\"nil\")");
            return value;
        end;

        method Print_Fixed_Array(array: Fixed_Array[Unit]): Unit is
            return nil;
        end;
    end;

    instance Printable(Nat8) is
        method Print(value: Nat8): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        method Print_Fixed_Array(array: Fixed_Array[Nat8]): Unit is
            for i from 0 to Fixed_Array_Size(array) - 1 do
                @embed(Unit, "au_printf(\"%c\", $1)", array[i]);
            end for;
            return nil;
        end;
    end;

    instance Printable(Nat16) is
        method Print(value: Nat16): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        method Print_Fixed_Array(array: Fixed_Array[Nat16]): Unit is
            return nil;
        end;
    end;

    instance Printable(Nat32) is
        method Print(value: Nat32): Unit is
            return @embed(Unit, "au_printf(\"%u\", $1)", value);
            return nil;
        end;

        method Print_Fixed_Array(array: Fixed_Array[Nat32]): Unit is
            return nil;
        end;
    end;

    instance Printable(Nat64) is
        method Print(value: Nat64): Unit is
            return @embed(Unit, "au_printf(\"%zu\", $1)", value);
            return nil;
        end;

        method Print_Fixed_Array(array: Fixed_Array[Nat64]): Unit is
            return nil;
        end;
    end;

    instance Printable(Int8) is
        method Print(value: Int8): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        method Print_Fixed_Array(array: Fixed_Array[Int8]): Unit is
            return nil;
        end;
    end;

    instance Printable(Int16) is
        method Print(value: Int16): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        method Print_Fixed_Array(array: Fixed_Array[Int16]): Unit is
            return nil;
        end;
    end;

    instance Printable(Int32) is
        method Print(value: Int32): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        method Print_Fixed_Array(array: Fixed_Array[Int32]): Unit is
            return nil;
        end;
    end;

    instance Printable(Int64) is
        method Print(value: Int64): Unit is
            return @embed(Unit, "au_printf(\"%li\", $1)", value);
            return nil;
        end;

        method Print_Fixed_Array(array: Fixed_Array[Int64]): Unit is
            return nil;
        end;
    end;

    instance Printable(Index) is
        method Print(value: Index): Unit is
            return @embed(Unit, "au_printf(\"%zu\", $1)", value);
            return nil;
        end;

        method Print_Fixed_Array(array: Fixed_Array[Index]): Unit is
            return nil;
        end;
    end;

    instance Printable(Float32) is
        method Print(value: Float32): Unit is
            return @embed(Unit, "au_printf(\"%f\", $1)", value);
            return nil;
        end;

        method Print_Fixed_Array(array: Fixed_Array[Float32]): Unit is
            return nil;
        end;
    end;

    instance Printable(Float64) is
        method Print(value: Float64): Unit is
            return @embed(Unit, "au_printf(\"%f\", $1)", value);
            return nil;
        end;

        method Print_Fixed_Array(array: Fixed_Array[Float64]): Unit is
            return nil;
        end;
    end;

    generic [B: Free(Printable)]
    instance Printable(Fixed_Array[B]) is
        method Print(value: Fixed_Array[B]): Unit is
            return Print_Fixed_Array(value);
        end;

        method Print_Fixed_Array(array: Fixed_Array[Fixed_Array[B]]): Unit is
            return nil;
        end;
    end;

    generic [T: Free(Printable)]
    function PrintLn(value: T): Unit is
        Print(value);
        return @embed(Unit, "au_printf(\"\n\")");
    end;
end module body.