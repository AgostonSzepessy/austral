module Austral.Memory is
    type Address[T: Type]: Free;
    type Pointer[T: Type]: Free;

    generic [T: Type]
    function nullPointer(): Address[T];

    generic [T: Type]
    function nullCheck(address: Address[T]): Option[Pointer[T]];

    generic [T: Type]
    function allocate(size: Index): Address[T];

    generic [T: Type]
    function Load(pointer: Pointer[T]): T;

    generic [T: Type]
    function Store(pointer: Pointer[T], value: T): Unit;

    generic [T: Type]
    function deallocate(pointer: Pointer[T]): Unit;

    generic [T: Type, R: Region]
    function Load_Read_Reference(ref: &[Pointer[T], R]): &[T, R];

    generic [T: Type, R: Region]
    function Load_Write_Reference(ref: &![Pointer[T], R]): &![T, R];

    generic [T: Type]
    function Resize_Array(array: Pointer[T], size: Index): Pointer[T];

    generic [T: Type, U: Type]
    function memmove(source: Pointer[T], destination: Pointer[U], count: Index): Unit;

    generic [T: Type, U: Type]
    function memcpy(source: Pointer[T], destination: Pointer[U], count: Index): Unit;

    generic [T: Type]
    function positiveOffset(pointer: Pointer[T], offset: Index): Pointer[T];

    generic [T: Type]
    function negativeOffset(pointer: Pointer[T], offset: Index): Pointer[T];
end module.