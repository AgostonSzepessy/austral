import Austral.Memory (
    Pointer,
    Null_Pointer,
    Allocate,
    Load,
    Store,
    Deallocate,
    Load_Read_Reference,
    Load_Write_Reference
);

module body Example.Box is
    pragma Unsafe_Module;

    record Box[T: Type]: Linear is
        pointer: Pointer[T];
    end;

    generic [T: Type]
    function Make(val: T): Either[Box[T], T] is
        let ptr: Pointer[T] := Allocate(sizeof(T));
        let null: Pointer[T] := Null_Pointer();
        if ptr = null then
            -- Allocation failed, return the object we tried to box.
            let right: Either[Box[T], T] := Right(right => val);
            return right;
        else
            Store(ptr, val);
            let box: Box[T] := Box(pointer => ptr);
            let left: Either[Box[T], T] := Left(left => box);
            return left;
        end if;
    end;

    generic [T: Type]
    function Unbox(box: Box[T]): T is
        let { pointer: Pointer[T] } := box;
        let value: T := Load(pointer);
        Deallocate(pointer);
        return value;
    end;

    generic [X: Free]
    function Swap_Free(box: Box[X], new: X): Box[X] is
        let { pointer: Pointer[X] } := box;
        let old: X := Load(pointer);
        Store(pointer, new);
        let newbox: Box[X] := Box(pointer => pointer);
        return newbox;
    end;

    generic [T: Free, R: Region]
    function Read_Free(boxref: Reference[Box[T], R]): T is
        let ptrref: Reference[Pointer[T], R] := boxref->pointer;
        let ptr: Pointer[T] := !ptrref;
        let value: T := Load(ptr);
        return value;
    end;

    generic [T: Free, R: Region]
    function Store_Free(boxref: WriteReference[Box[T], R], value: T): Unit is
        let ptrref: WriteReference[Pointer[T], R] := boxref->pointer;
        let ptr: Pointer[T] := !(ptrref);
        Store(ptr, value);
        return nil;
    end;

    generic [T: Type, R: Region]
    function Get_Value_Ref(boxref: Reference[Box[T], R]): Reference[T, R] is
        let ptrref: Reference[Pointer[T], R] := boxref->pointer;
        let ref: Reference[T, R] := Load_Read_Reference(ptrref);
        return ref;
    end;

    generic [T: Free, R: Region]
    function Swap_Mut(boxref: WriteReference[Box[T], R], value: T): T is
        let ptr: Pointer[T] := !(boxref->pointer);
        let old_value: T := Load(ptr);
        Store(ptr, value);
        return old_value;
    end;

    function Put_Character(character: Integer_32): Integer_32 is
        pragma Foreign_Import(External_Name => "putchar");
    end;

    function Main(root: Root_Capability): Root_Capability is
        -- Box a value, swap it, and unwrap it.
        let b: Either[Box[Integer_32], Integer_32] := Make('e');
        case b of
            when Left(left: Box[Integer_32]) do
                let newbox: Box[Integer_32] := Swap_Free(left, 'a');
                let contents: Integer_32 := Unbox(newbox);
                Put_Character(contents);
            when Right(right: Integer_32) do
                Abort("Unexpected.");
        end case;
        -- Box a value, read_free it and unbox it.
        let b2: Either[Box[Integer_32], Integer_32] := Make('a');
        case b2 of
            when Left(left: Box[Integer_32]) do
                borrow left as value2 in rho do
                    let contents: Integer_32 := Read_Free(value2);
                    Put_Character(contents);
                end;
                Unbox(left);
            when Right(right: Integer_32) do
                Abort("Unexpected.");
        end case;
        -- Box a value, store a new one through a mutable reference, and unbox it.
        let b3: Either[Box[Integer_32], Integer_32] := Make('e');
        case b3 of
            when Left(left: Box[Integer_32]) do
                borrow! left as value2 in rho do
                    Store_Free(value2, 'a');
                end;
                let contents: Integer_32 := Unbox(left);
                Put_Character(contents);
            when Right(right: Integer_32) do
                Abort("Unexpected.");
        end case;
        -- Box a value, load it through a reference, and unbox it.
        let b4: Either[Box[Integer_32], Integer_32] := Make('a');
        case b4 of
            when Left(left: Box[Integer_32]) do
                borrow left as boxref in rho do
                    let valueref: Reference[Integer_32, rho] := Get_Value_Ref(boxref);
                    let contents: Integer_32 := !(valueref);
                    Put_Character(contents);
                end;
                Unbox(left);
            when Right(right: Integer_32) do
                Abort("Unexpected.");
        end case;
        -- Box a value, swap it through a mutable reference, and unbox it.
        let b5: Either[Box[Integer_32], Integer_32] := Make('e');
        case b5 of
            when Left(left: Box[Integer_32]) do
                borrow! left as boxmutref in rho do
                    Swap_Mut(boxmutref, 'a');
                end;
                Put_Character(Unbox(left));
            when Right(right: Integer_32) do
                Abort("Unexpected.");
        end case;
        return root;
    end;
end module body.
