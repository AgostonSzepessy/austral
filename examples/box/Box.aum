import Austral.Memory (
    Pointer,
    Allocate,
    Load,
    Store,
    Deallocate
);

module body Example.Box is
    record Box[T: Type]: Linear is
        pointer: Pointer[T];
    end;

    generic [T: Type]
    function Make(val: T): Option[Box[T]] is
        let ptr: Option[Pointer[T]] := Allocate(val);
        case ptr of
            when Some(value: Pointer[T]) do
                let box: Box[T] := Box(pointer => value);
                let boxopt: Option[Box[T]] := Some(value => box);
                return boxopt;
            when None do
                let boxopt: Option[Box[T]] := None();
                return boxopt;
        end case;
    end;

    generic [T: Type]
    function Unbox(box: Box[T]): T is
        let { pointer: Pointer[T] } := box;
        let value: T := Load(pointer);
        Deallocate(pointer);
        return value;
    end;

    function Put_Character(character: Integer_32): Integer_32 is
        pragma Foreign_Import(External_Name => "putchar");
    end;

    function Main(): Unit is
        let b: Option[Box[Integer_32]] := Make(97);
        case b of
            when Some(value: Box[Integer_32]) do
                let contents: Integer_32 := Unbox(value);
                Put_Character(contents);
            when None do
                skip;
        end case;
        return nil;
    end;
end module body.
