import Austral.Memory (
    Address,
    Pointer,
    Null_Check,
    Allocate,
    Deallocate,
    Positive_Offset,
    Load,
    Store
);

module body Example.Array is
    pragma Unsafe_Module;

    function Put_Character(character: Nat8): Int32 is
        pragma Foreign_Import(External_Name => "putchar");
    end;

    function Show_Bool(b: Bool): Unit is
        if b then
            Put_Character(84);
        else
            Put_Character(70);
        end if;
        return nil;
    end;

    function Main(root: Root_Capability): Root_Capability is
        let addr: Address[Bool] := Allocate(3);
        case Null_Check(addr) of
            when Some(value: Pointer[Bool]) do
                let arr: Pointer[Bool] := value;
                let firstp: Pointer[Bool] := arr;
                let secondp: Pointer[Bool] := Positive_Offset(arr, 1);
                let thirdp: Pointer[Bool] := Positive_Offset(arr, 2);
                Store(firstp, true);
                Store(secondp, false);
                Store(thirdp, true);
                let first: Bool := Load(firstp);
                let second: Bool := Load(secondp);
                let third: Bool := Load(thirdp);
                Show_Bool(first);
                Show_Bool(second);
                Show_Bool(third);
                Deallocate(arr);
            when None do
                skip;
        end case;
        return root;
    end;
end module body.
